

## 第二次作业

​	简单数学题，明显比第一次难了啊

-------------------------

+ 1001  `a+b` 不用 ` (n+1)*n/2` 因为会溢出 

  >  You may assume the result will be in the range of 32-bit signed integer.

+  1002 电梯问题简单题  每个人5秒的固定停留时间 N*5  在原来的基础上上楼或者下楼乘以6或者4即可

+ 1009是两个数的最小公倍数 1003是多个数的最小公倍数 

  + 方法一 用辗转相除法，求出两个数的最大公因数 最小公倍数为 ` A*B/最大公约数 `（辗转相除法 如果传入的参数是先小后大也不要紧 进过第一轮的转换 大的数会变成大的 小的变成小的）

    多个数的最小公倍数 先得到两个数的最小公倍数K K再和另外的数得到最小公倍数 

    12 8 4 --> 24 4 --> 24 

  ``` c
  int gcd(int da,int xiao)
  {
  	int temp;
  	while(xiao!=0)
  	{
  		temp = da%xiao;
  		da = xiao;
  		xiao = temp;
  	}
  	return da;
  }
  ```

  ​	辗转相除法递归实现 一行即可

  ``` c
  int GCD(int a,int b）
  {
  	return b==0?a:GCD(b,a%b);
  }
  ```

  + 方法二 暴力做 如 10和14的最小公倍数 分别看 `14` `14+14` ` 14+14+14` ... 能不能被10整除

+ 1004 和 1005 

  + 看到取余要留心 取余导致最后结果数值很小 根据抽屉原理 一定会出现循环  又n都是根据前两项算出来的
  + 取余的相关运算 ` (a + b) % p = (a % p + b % p) % p `
  + 1004 mod7 所以n的值在0-6之间 一共7种可能 两个两个取 一共有7*7=49种可能 意思是最多取50组 肯定会出现重复 存入数组中 在数组中找到循环节
  + 1005 很容易算出 8个一循环 （看似这么复杂的问题 找到规律 四五行代码就搞定了 ）

+ 1006 吃糖果 最大数不能太大 最大数 其他数之和 相差大于1就不可以了 小于等于1都可以 要注意的是 sum要用 long long 

+ 1007 快速幂  

  + n&1-->n%2  if(n&1)-->如果n是奇数                              
  + n>>=1 -> n/2 

  ``` 
  while(B!=0)
  {
  	if(B%2==1)
  {
  	temp*=A;//是奇数的话 乘个A 降一次 
  }
  	A=A*A;
  	B/=2;
  }
  printf("%d\n",temp);
  ```

+ 1008 个位数的值 

  + 0 1 5 6 不变
  + 2->4->8->6->2....
  + 3 和 9 同理
  + 7同理



